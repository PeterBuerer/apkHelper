#!/bin/bash

function cmd_help
{
    if [ "$1" = "" ]; then
        help_help
    elif [ "$1" = "-v" ]; then
        #all help functions
        echo
    else
        while [ "$1" != "" ]; do
            #case "$1" in 
            #[cC]ommand ) help_function;;
            #* ) problem_encountered "Not a valid command";;
            #esac
            shift
        done
    fi
}

function help_help
{
    echo "This is of no help right now"
}

#called to end script in error
function problem_encountered
{
    if [ "$1" != "" ]; then
        echo "$1" >&2
    fi
    #clean_up
    echo 'type "help" for usage page' >&2
    exit 1
}

# function clean_up
# {
# }

#called to end the script with success
function script_done
{
    #clean_up
    echo "done"
    exit 0
}

function cmd_verify
{
   #options: 
	# -certs
	# -verbose 

    #Question: Should this cmd accept -verbose and -v?
   opts="-verify"
   if [ "$1" = "-verbose" -o "$1" = "-v" ]; then     
       opts="$opts -verbose"
       shift
   fi

   if [ "$1" = "-certs" -o "$1" = "-c" ]; then
	 opts="$opts -certs"
	 shift
   fi
	
   #check to see if a valid file is passed to the method (just .jar and .apk????)

   filetype="${1##*.}"
   if [ "$filetype" = "apk" ]; then
       echo "is an apk"
       #$(jarsigner "$opts" "$1")                    ####uncomment when go time
       #echo "jarsigner "$opts" "$1""
   else 
      problem_encountered  "file not an apk"
   fi 
 
   #Verify an APK:
   #$ jarsigner -verify –verbose [-certs] theapp.apk
}
 
function cmd_sign
{
    opts=""
    if [ "$1" = "-verbose" -o "$1" = "-v" ]; then
        opts="-verbose"
        shift
    fi
   
    #Question: How do you want these commands to be structured so that this script is more useful than just typing in the individual commands. Should the script just take a ton of args up front and the verify -> sign (if not signed) -> zipalign while still having the option to do each command individually?
   
    
  #SIGN AN APK:
  #$ jarsigner -verbose –keystore ~/Publishing/Resources/something.keystore unsigned.apk "alias"
  
  #check to make sure that the earl given leads to a .keystore ???
  
  #check to make sure that they give you an apk (or jar???)
  #if no alias is provided, kick 'em
  #Question: What should happen if a -keystore url is not specified?
  

#setup and parse args
# Keystore Pass (...)
# PrivateKey Pass (...)

  echo "sign"
}
 
function cmd_zipalign
{
  # make sure that the apk is signed? If you sign after zipalign, it messes up the alignment
  # Question: Should -v be optional?

  signed="" 
  if [ "${1##*.}" = "apk" ]; then
      #verify
      #if passed
        #signed="$1"
  fi

  #Question: Should we force the outfile to have a .apk extension?
  if [ "$2" != ""]; then
      #align with the two given names
      #zipalign -v 4 "$signed" "$2"
      echo "aligned to output file: "$2""
  else
      #align with a default output name
      #zipalign -v 4 "$signed" "output-zipaligned.apk"
      echo "aligned to output-zipaligned.apk"
  fi

  # ZIPALIGN THE SIGNED APK
  # $ zipalign -v 4 "signed.apk" "signed-zipaligned.apk"

  echo "zipalign"
}


#Install
#if jarsign and/or zipalign are not in any folders in the path, put them in /usr/bin



###MAIN###

cmd="$1"
#bd="$(pwd)"

#if there was no command, exit
if [ "$cmd" = "" ]; then
    problem_encountered "no command"
else
    shift
fi

#if cmd was "help" or "h" show the usage page
if [ "$cmd" = "help" -o "$cmd" = "h" ]; then 
    cmd_help "$@"
    script_done
fi

#Commands

if [ "$cmd" = "verify" -o "$cmd" = "v" ]; then
    cmd_verify "$@"
    script_done
elif [ "$cmd" = "sign" -o "$cmd" = "s" ]; then
    cmd_sign "$@"
    script_done
elif [ "$cmd" = "zipalign" -o "$cmd" = "z" ]; then
    cmd_zipalign "$@"
    script_done
fi

#verify -verbose? the.apk

#sign the.apk

#zipalign or just align or something 





